// Generate input logs with: GST_DEBUG="GST_TRACER:7" GST_TRACERS=stats

use failure::Error;
use gst_log_parser::parse;
use gstreamer::{ClockTime, DebugLevel, Structure};
use std::collections::HashMap;
use std::fs::File;
use std::path::PathBuf;
use structopt::StructOpt;

#[derive(StructOpt, Debug, PartialEq, Copy, Clone)]
#[structopt(name = "command")]
enum Command {
    #[structopt(name = "check-decreasing-pts", about = "Check for decreasing PTS")]
    DecreasingPts,
}

#[derive(StructOpt, Debug)]
#[structopt(name = "flow", about = "Process logs generated by the 'stats' tracer")]
struct Opt {
    #[structopt(parse(from_os_str))]
    input: PathBuf,
    #[structopt(subcommand)]
    command: Command,
}

#[derive(Debug)]
struct Element {
    name: String,
}

impl Element {
    fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
        }
    }
}

#[derive(Debug)]
struct Pad {
    name: String,
    last_buffer_pts: ClockTime,
}

impl Pad {
    fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            last_buffer_pts: ClockTime::none(),
        }
    }
}

#[derive(Debug)]
struct Flow {
    command: Command,
    elements: HashMap<u32, Element>,
    pads: HashMap<u32, Pad>,
}

impl Flow {
    fn new(command: Command) -> Self {
        Self {
            command,
            elements: HashMap::new(),
            pads: HashMap::new(),
        }
    }

    fn parse(&mut self, s: &Structure) {
        match s.get_name() {
            "new-element" => {
                let idx = s.get::<u32>("ix").unwrap();
                self.elements
                    .entry(idx)
                    .or_insert_with(|| Element::new(s.get::<&str>("name").unwrap()));
            }
            "new-pad" => {
                let idx = s.get::<u32>("ix").unwrap();
                self.pads
                    .entry(idx)
                    .or_insert_with(|| Pad::new(s.get::<&str>("name").unwrap()));
            }
            "buffer" => {
                self.handle_buffer(s);
            }
            _ => {}
        }
    }

    fn handle_buffer(&mut self, s: &Structure) {
        let pad = self
            .pads
            .get_mut(&s.get::<u32>("pad-ix").unwrap())
            .expect("Unknown pad");
        let element = self
            .elements
            .get(&s.get::<u32>("element-ix").unwrap())
            .expect("Unknown element");

        if s.get::<bool>("have-buffer-pts").unwrap() {
            let pts = ClockTime::from_nseconds(s.get::<u64>("buffer-pts").unwrap());

            if self.command == Command::DecreasingPts
                && pad.last_buffer_pts.is_some()
                && pts < pad.last_buffer_pts
            {
                println!(
                    "Decreasing pts {}:{} {} < {}",
                    element.name, pad.name, pts, pad.last_buffer_pts
                );
            }
            pad.last_buffer_pts = pts;
        }
    }
}

fn main() -> Result<(), Error> {
    let opt = Opt::from_args();
    let input = File::open(opt.input)?;
    let mut flow = Flow::new(opt.command);

    let parsed = parse(input)
        .filter(|entry| entry.category == "GST_TRACER" && entry.level == DebugLevel::Trace);

    for entry in parsed {
        let s = match entry.message_to_struct() {
            None => continue,
            Some(s) => s,
        };

        flow.parse(&s);
    }

    Ok(())
}
